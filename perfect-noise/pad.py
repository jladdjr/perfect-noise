import os
from hashlib import sha3_256
from math import ceil
from pathlib import Path
from secrets import choice

from perfect-noise.exceptions import EmptyOneTimePadException
from perfect-noise.hazmat.hazmat import get_random_bytes
from perfect-noise.settings import MAX_BLOCK_SIZE, STD_BLOCK_SIZE


@staticmethod
def create_one_time_pad(path: Path, size: int):
    """Creates a pad at `path`.

    Note that `path`'s parent folder should already exist.

    Arguments:
    path -- path to a new one-time pad
    size -- desired size of pad; resulting pad will be at least this large
    """
    if not path.parent.exists():
        error_msg = (
            f"Cannot create one-time pad at {path}; "
            + "parent directory does not exist"
        )
        raise ValueError(error_msg)
    if path.exists():
        error_msg = (
            f"Cannot create one-time pad at {path}; "
            + "file or directory already present at location"
        )
        raise ValueError(error_msg)

    # create new directory representing the pad itself
    os.mkdir(path, 0o700)

    num_blocks = ceil(size / STD_BLOCK_SIZE)

    for _ in range(num_blocks):
        create_block_file(path, STD_BLOCK_SIZE)


@staticmethod
def create_block_file(path: Path, size: int):
    """Creates a block file suitable for use as a one-time pad.
    The block file's data will be generated by the operating system's
    pseudorandom number generator via `os.urandom`.

    Note that `path`'s folder should already exist.

    Arguments:
    path -- `Path` object that references an existing directory
            where block file should be created (e.g. /home/alice/pads/my.pad)
    size -- size of block file in bytes (must be less than `MAX_BLOCK_SIZE`)
    """
    if size > MAX_BLOCK_SIZE:
        raise ValueError(
            (
                f"Cannot create blocks larger than {MAX_BLOCK_SIZE} bytes. "
                + f"Received request for {size} bytes."
            )
        )

    data = get_random_bytes(size)

    # use sha3-256 digest of block for filename
    sha = sha3_256(data, usedforsecurity=True).hexdigest()
    block_file = path.joinpath(sha)

    # create block file
    with open(block_file, "wb") as f:
        f.write(data)

    os.chmod(block_file, 0o400)

    return sha


@staticmethod
def fetch_and_destroy_block(pad_path: Path, block_name) -> bytes:
    """Retrieves a block `block_name` from pad located
    at `pad_path`. Collects the bytes from the block and destroys the
    block file. Returns the bytes retrieved from the block file.

    Arguments:
    `pad_path` -- path to the one-time pad
    `block_name` -- name used to identify block (typically a SHA of block's contents)
    """
    block_path = pad_path.joinpath(block_name)

    block_bytes = None
    with open(block_path, "rb") as block:
        block_bytes = block.read()

    os.remove(block_path)
    return block_bytes


@staticmethod
def fetch_and_destroy_random_block(pad_path: Path) -> (str, bytes):
    """Randomly selects a block from pad located at `pad_path`,
    collects the bytes from the block, notes the block's filename,
    and destroys the block file. Returns the name of the block file and
    the bytes from the block file.

    Arguments:
    `pad_path` -- path to the one-time pad
    """
    block_list = os.listdir(pad_path)
    if len(block_list) == 0:
        raise EmptyOneTimePadException()

    block_name = choice(block_list)
    block_path = pad_path.joinpath(block_name)

    block_bytes = None
    with open(block_path, "rb") as block:
        block_bytes = block.read()

    os.remove(block_path)
    return (block_name, block_bytes)
