import os
from hashlib import sha3_256
from math import ceil
from pathlib import Path
from secrets import choice

from .hazmat.hazmat import get_random_bytes
from .settings import MAX_BLOCK_SIZE, DEFAULT_BLOCK_SIZE, DEFAULT_PAD_SIZE


class EmptyOneTimePadException(Exception):
    pass


def create_block_file(path: Path, size: int):
    """Creates a block file suitable for use as a one-time pad.
    The block file's data will be generated by the operating system's
    pseudorandom number generator via `os.urandom`.

    Note that `path`'s folder should already exist.

    Arguments:
    path -- `Path` object that references desired path of new block file.
            (e.g. Path("/home/alice/pads/my.pad/0000000000000000") )
            Note that the parent directory of the block file should
            already exist.
    size -- size of block file in bytes (must be less than `MAX_BLOCK_SIZE`)
    """
    if size > MAX_BLOCK_SIZE:
        raise ValueError(
            (
                f"Cannot create blocks larger than {MAX_BLOCK_SIZE} bytes. "
                + f"Received request for {size} bytes."
            )
        )

    data = get_random_bytes(size)
    # create block file
    with open(path, "wb") as f:
        f.write(data)

    os.chmod(path, 0o400)


def fetch_and_destroy_block(pad_path: Path, block_name) -> bytes:
    """Retrieves a block `block_name` from pad located
    at `pad_path`. Collects the bytes from the block and destroys the
    block file. Returns the bytes retrieved from the block file.

    Arguments:
    `pad_path` -- path to the one-time pad
    `block_name` -- name used to identify block (typically a SHA of block's contents)
    """
    block_path = pad_path.joinpath(block_name)

    block_bytes = None
    with open(block_path, "rb") as block:
        block_bytes = block.read()

    os.remove(block_path)
    return block_bytes


def _get_random_block(pad_path: Path) -> str:
    """Given a path to a pad, returns the name of a random block"""
    block_list = os.listdir(pad_path)
    if len(block_list) == 0:
        raise EmptyOneTimePadException()
    return choice(block_list)


def fetch_and_destroy_random_block(pad_path: Path) -> (str, bytes):
    """Randomly selects a block from pad located at `pad_path`,
    collects the bytes from the block, notes the block's filename,
    and destroys the block file. Returns the name of the block file and
    the bytes from the block file.

    Arguments:
    `pad_path` -- path to the one-time pad
    """
    block_name = _get_random_block(pad_path)
    block_bytes = fetch_and_destroy_block(pad_path, block_name)
    return (block_name, block_bytes)


def create_one_time_pad(
    path: Path, size: int = DEFAULT_BLOCK_SIZE, block_size: int = DEFAULT_BLOCK_SIZE
) -> None:
    """Creates a pad at `path`.

    Note that `path`'s parent folder should already exist.

    Arguments:
    path -- path to a new one-time pad
    size -- desired size of pad; resulting pad will be at least this large
    block_size -- desired size of block
    """
    if not path.parent.exists():
        error_msg = (
            f"Cannot create one-time pad at {path}; "
            + "parent directory does not exist"
        )
        raise ValueError(error_msg)
    if path.exists():
        error_msg = (
            f"Cannot create one-time pad at {path}; "
            + "file or directory already present at location"
        )
        raise ValueError(error_msg)
    if size < 1:
        raise ValueError(f"Pad size must be greater than zero. Received {size}")
    if block_size < 1:
        raise ValueError(f"Block size must be greater than zero. Received {block_size}")
    if block_size > size:
        error = (
            "Block size cannot be greater than pad size. "
            + f"Received {size} for pad size, "
            + f"{block_size} for block size."
        )
        raise ValueError(error)

    # create new directory representing the pad itself
    os.mkdir(path, 0o700)

    num_blocks = ceil(size / block_size)

    for i in range(num_blocks):
        block_path = path.joinpath(str(i).zfill(16))
        create_block_file(block_path, block_size)
